// CVE Vulnerability Database Lookup API
import fetch from 'node-fetch';

const CVE_PATTERNS = {
    'Apache': /Apache[\/\s]httpd[\/\s]([\d.]+)/i,
    'OpenSSL': /OpenSSL[\/\s]([\d.]+[a-z]?)/i,
    'PHP': /PHP[\/\s]([\d.]+)/i,
    'nginx': /nginx[\/\s]([\d.]+)/i,
    'MySQL': /MySQL[\/\s]([\d.]+)/i,
    'PostgreSQL': /PostgreSQL[\/\s]([\d.]+)/i,
    'SSH': /OpenSSH[\/\s]([\d.]+[p\d]*)/i,
    'IIS': /Microsoft-IIS[\/\s]([\d.]+)/i
};

const KNOWN_VULNS = {
    'Apache/2.4.6': [
        { cve: 'CVE-2021-44790', severity: 'CRITICAL', description: 'Buffer overflow in mod_lua', exploitable: true },
        { cve: 'CVE-2021-26691', severity: 'HIGH', description: 'mod_session cookie handling', exploitable: true },
        { cve: 'CVE-2017-15715', severity: 'HIGH', description: 'Expression parsing bypass', exploitable: true }
    ],
    'OpenSSL/1.0.2': [
        { cve: 'CVE-2016-2107', severity: 'CRITICAL', description: 'Padding oracle vulnerability', exploitable: true },
        { cve: 'CVE-2016-0800', severity: 'HIGH', description: 'DROWN attack', exploitable: true },
        { cve: 'CVE-2014-0160', severity: 'CRITICAL', description: 'Heartbleed - memory disclosure', exploitable: true }
    ],
    'PHP/7.4': [
        { cve: 'CVE-2022-31625', severity: 'HIGH', description: 'Uninitialized array in pg_query_params', exploitable: true },
        { cve: 'CVE-2021-21708', severity: 'CRITICAL', description: 'Use after free in php_filter_float', exploitable: true }
    ]
};

export default async function handler(req, res) {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }
    
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        const { scanOutput } = req.body;
        
        if (!scanOutput) {
            return res.status(400).json({ error: 'Scan output required' });
        }

        console.log('üîç Analyzing scan output for CVEs...');
        
        const vulnerabilities = [];
        const detectedSoftware = [];
        
        // Parse software versions from scan output
        for (const [software, pattern] of Object.entries(CVE_PATTERNS)) {
            const match = scanOutput.match(pattern);
            if (match) {
                const version = match[1];
                detectedSoftware.push({ software, version, fullMatch: match[0] });
                console.log(`‚úÖ Found: ${software} ${version}`);
                
                // Check known vulnerabilities
                for (const [vulnKey, vulns] of Object.entries(KNOWN_VULNS)) {
                    if (match[0].includes(vulnKey.split('/')[0])) {
                        vulnerabilities.push(...vulns.map(v => ({
                            ...v,
                            software,
                            version,
                            affectedVersion: vulnKey
                        })));
                    }
                }
            }
        }
        
        // Try NVD API for real-time CVE lookup (if we have specific versions)
        const nvdResults = [];
        for (const sw of detectedSoftware) {
            try {
                const nvdUrl = `https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${sw.software} ${sw.version}`;
                const nvdResponse = await fetch(nvdUrl, {
                    headers: { 'User-Agent': 'Atom-Security-Scanner/1.0' },
                    timeout: 5000
                });
                
                if (nvdResponse.ok) {
                    const nvdData = await nvdResponse.json();
                    if (nvdData.vulnerabilities && nvdData.vulnerabilities.length > 0) {
                        nvdResults.push(...nvdData.vulnerabilities.slice(0, 3).map(v => ({
                            cve: v.cve.id,
                            severity: v.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity || 'UNKNOWN',
                            description: v.cve.descriptions?.[0]?.value || 'No description',
                            source: 'NVD'
                        })));
                    }
                }
            } catch (nvdError) {
                console.log(`‚ö†Ô∏è NVD lookup failed for ${sw.software}: ${nvdError.message}`);
            }
        }
        
        // Combine results
        const allVulns = [...vulnerabilities, ...nvdResults];
        
        // Calculate risk score
        const riskScore = calculateRiskScore(allVulns);
        
        console.log(`‚úÖ Found ${allVulns.length} vulnerabilities, risk score: ${riskScore}`);
        
        res.json({
            success: true,
            detectedSoftware,
            vulnerabilities: allVulns,
            riskScore,
            summary: generateSummary(allVulns, riskScore)
        });
        
    } catch (error) {
        console.error('CVE Lookup Error:', error);
        res.status(500).json({ error: error.message });
    }
}

function calculateRiskScore(vulnerabilities) {
    let score = 0;
    for (const vuln of vulnerabilities) {
        if (vuln.severity === 'CRITICAL') score += 10;
        else if (vuln.severity === 'HIGH') score += 7;
        else if (vuln.severity === 'MEDIUM') score += 4;
        else if (vuln.severity === 'LOW') score += 2;
        
        if (vuln.exploitable) score += 3;
    }
    return Math.min(100, score);
}

function generateSummary(vulnerabilities, riskScore) {
    const critical = vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
    const high = vulnerabilities.filter(v => v.severity === 'HIGH').length;
    const exploitable = vulnerabilities.filter(v => v.exploitable).length;
    
    let summary = `Risk Score: ${riskScore}/100\n`;
    summary += `\nüî¥ CRITICAL: ${critical}`;
    summary += `\nüü† HIGH: ${high}`;
    summary += `\n‚ö° Exploitable: ${exploitable}`;
    
    if (riskScore > 70) {
        summary += `\n\n‚ö†Ô∏è SEVERE: Immediate action required!`;
    } else if (riskScore > 40) {
        summary += `\n\n‚ö†Ô∏è HIGH RISK: Patch recommended.`;
    }
    
    return summary;
}
